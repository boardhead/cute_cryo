<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!--
********************************************************************************
** File:        cute_cryo.html
**
** Description: CUTE cryostat position control web client
**
** Revisions:   2017-03-08 - P. Harvey created
********************************************************************************
-->
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>CUTE Cryostat Position Control</title>
</head>
<body>
<style type="text/css">
<!--
div.lg  { font:14px verdana; border:1px solid #d3d3d3; padding:3px 6px 3px 6px;
          width:668px; line-height:1.2em; overflow:auto }
.brd    { border:1px solid #d3d3d3; }
.no     { border:0; margin:0; padding:0 }
.ca     { font:16px verdana; color:#444444; border:1px solid #d3d3d3; width:340px; height:70px; }
.tl     { padding: 8px 15px 5px 5px }
.tr     { padding: 8px 5px 5px 10px }
.tl2    { padding: 1px 15px 5px 5px }
.tr2    { padding: 1px 5px 5px 10px }
</style>

<table class=no><tr><td colspan=2><div id="title" class=lg>
<center><h3 style='margin:.5em'>CUTE Cryostat Position Control <span id="onOff"></span></h3></center>
</div></td></tr>

<tr><td><canvas id="can3" class=brd width="334" height="70"></canvas></td>
<td><div class="ca">
<form action="/action_page.php" method="get" id="form1">
<table width="100%">
<tr valign="bottom"><td class=tl align="right">Active Control:</td><td class=tr>
  <input type="radio" name="active" id="act1" value="1" onclick="Activate(1)"> On &nbsp; &nbsp;
  <input type="radio" name="active" id="act0" value="0" onclick="Activate(0)"> Off
</td></tr>
<tr><td class=tl2 align="right" width="50%">Air Pressure:</td>
<td class=tr2><span id="air">1013</span> hPa</td></tr>
</table>
</form>
</div></td>
</tr>

<tr>
<td><canvas id="can0" class=brd width="334" height="250"></canvas></td>
<td><canvas id="can2" class=brd width="340" height="250"></canvas></td>
</tr>

<tr><td colspan=2>
<canvas id="can1" class=brd width="680" height="260">
Your browser does not support the HTML5 canvas tag.</canvas></td></tr>

<tr><td colspan=2>
<div id="log" class="lg brd" style="height:12em;"></div>
</td></tr>

<tr><td colspan=2>
<div id="typ" class="lg brd" style="height:2em;">Comment:
<input type="text" id="com" size="75" style="font:14px verdana" onkeypress="Comment(event)"></div>
</td></tr>

</table>

<script type="text/javascript">
const kHistoryLen = 600;

// canvas numbers
const kCanPos = 0;  // positions
const kCanHis = 1;  // position history
const kCanLod = 2;  // loads
const kCanSpd = 3;  // motor speeds

// CUTE parameters
var max = 2;        // max height in mm
var min = 0;        // min height in mm
var nom = 1;        // nominal height in mm
var tol = 0.1;      // tolerance in mm
var rng = max - min;

var loadMin = 0;    // minimum load (kg)
var loadMax = 50;   // maximum load (kg)
var loadNom = 25;   // nominal load (kg);
var loadTol = 2.5;  // load tolerance (kg)
var loadRng = loadMax - loadMin;

var cans = [];      // our drawing canvases
var ctxs = [];      // our graphics contexts
var cx = [];        // canvas widths
var cy = [];        // canvas heights
for (var i=0; i<4; ++i) {
    cans[i] = document.getElementById('can'+i);
    ctxs[i] = cans[i].getContext('2d');
    ScaleCanvas(i);
}

// drawing constants
var bx = 50;        // left margin
var by = 35;        // top margin
var sep = 100;      // separation between scales
var scly = cy[kCanPos] - by - 40;   // scale height
var numTicks = 20;

var his = [ ];      // NOTE: don't call this "history" -- doesn't work in Firefox
var hisTime = -1;
var airPressure = 1013; // current air pressure (hPa)
var active = -1;    // current control state (-1=don't know, 0=inactive, 1=active)

var gradient=ctxs[kCanPos].createLinearGradient(0,by,0,scly+by);
gradient.addColorStop(0,   "#ff0000");
gradient.addColorStop(0.3, "#ffff00");
gradient.addColorStop(0.35,"#ffff00");
gradient.addColorStop(0.5, "#00dd00");
gradient.addColorStop(0.65,"#44ffff");
gradient.addColorStop(0.7, "#44ffff");
gradient.addColorStop(1.0, "#0000ff");

var damperLbl = ["A","B","C"];
var damperCol = ["#dd0000","#00aa00","#0000ff"];
var needDrawHis = 1;
var cuteServer;

// Scale canvas to draw at full device resolution
function ScaleCanvas(cnum)
{
    var can = cans[cnum];
    var rect = can.getBoundingClientRect();
    cx[cnum] = can.width;
    cy[cnum] = can.height;
    can.style.height = can.height + 'px';
    can.style.width  = can.width + 'px';
    // (minus 2 for border thickness)
    can.width  = Math.round(devicePixelRatio * rect.right) -
                 Math.round(devicePixelRatio * rect.left) - 2;
    can.height = Math.round(devicePixelRatio * rect.bottom) -
                 Math.round(devicePixelRatio * rect.top) - 2;
    ctxs[cnum].scale(can.width/cx[cnum], can.height/cy[cnum]);
}

function Comment(event)
{
    if (event.which == 13) {
        Send('Log:"'+com.value+'"');
        com.value = "";
    }
}

function Send(cmd)
{
    if (cuteServer) cuteServer.send(cmd);
}

// Activate/deactivate position control
function Activate(on)
{
    // reset radio buttons to reflect hardware state
    act0.checked = (active == 0);
    act1.checked = (active == 1);
    onOff.innerHTML = active == 1 ? "(On)" : "(Off)";

    if (active != on) {
        if (on == "1") {
            Send("On");
        } else if (window.confirm("Turn off position control?\n\nARE YOU SURE?")) {
            Send("Off");
        }
    }
}

// Draw all motor speeds (canvas kCanSpd)
function DrawSpeeds(vals)
{
    var ctx = ctxs[kCanSpd];
    ctx.clearRect(0, 0, cx[kCanSpd], cy[kCanSpd]);
    ctx.fillStyle="#444444";
    ctx.font="16px verdana";
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("Motor speeds (steps/sec)", cx[kCanSpd]/2, 20);
    ctx.textAlign="left";
    for (var i=0; i<3; ++i) {
        DrawSpeed(kCanSpd, 75 + sep * i, vals ? vals[i] : null);
    }
}

// Draw a motor speed indicator
function DrawSpeed(cnum, x, val)
{
    var ctx = ctxs[cnum];
    var y = 48;
    ctx.beginPath();
    if (!val) {
        // draw "X" to indicate motor is stopped
        ctx.moveTo(x-29, y-9);
        ctx.lineTo(x-11, y+9);
        ctx.moveTo(x-11, y-9);
        ctx.lineTo(x-29, y+9);
        ctx.strokeStyle="#888888";
        ctx.stroke();
        if (val == null) return;
    } else {
        // draw up/down triangle to indicate motor direction
        if (val < 0) {
            ctx.moveTo(x-29, y-9+1);
            ctx.lineTo(x-20, y+9+1);
            ctx.lineTo(x-11, y-9+1);
        } else {
            ctx.moveTo(x-29, y+9-1);
            ctx.lineTo(x-20, y-9-1);
            ctx.lineTo(x-11, y+9-1);
        }
        ctx.closePath();
        ctx.strokeStyle="#000000";
        ctx.stroke();
        ctx.fillStyle = "#ff0000";
        ctx.fill();
    }
    // draw motor speed as text
    ctx.fillStyle="#444444";
    ctx.fillText(val, x, y);
}

// Draw damper position indicators (canvas kCanPos)
function DrawDamperPositions(vals)
{
    var ctx = ctxs[kCanPos];
    ctx.clearRect(0, 0, cx[kCanPos], cy[kCanPos]);
    // draw y-axis label
    ctx.fillStyle="#444444";
    ctx.font="16px verdana";
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    ctx.fillText("Damper positions (mm)", cx[kCanPos]/2, cy[kCanPos]-20);
    DrawIndicators(kCanPos, vals, 0, 2, nom, tol, .1, .5, 1);
}

// Draw damper load indicators (canvas kCanLod)
function DrawDamperLoads(vals)
{
    var ctx = ctxs[kCanLod];
    var dl = (airPressure - 1013) * 10; // TEST

    ctx.clearRect(0, 0, cx[kCanLod], cy[kCanLod]);
    // draw y-axis label
    ctx.fillStyle="#444444";
    ctx.font="16px verdana";
    ctx.textBaseline="middle";
    ctx.textAlign="center";
    ctx.fillText("Add weights (kg)", cx[kCanLod]/2, cy[kCanLod]-20);
    if (vals) {
        for (var i=0; i<3; ++i) {
            vals[i] = loadNom - (Number(vals[i]) - dl);
        }
    }
    DrawIndicators(kCanLod, vals, -loadNom, loadNom*2, loadNom, loadTol, 2, 10, 0);
}

// Draw all 3 position/load indicators
// Inputs: cnum=canvas number, vals=load value array, min=scale minimum
//         rng=scale range, nom=nominal value, tick=tick spacing,
//         lbl=label spacing, dec=decimal digits
function DrawIndicators(cnum, vals, min, rng, nom, tol, tick, lbl, dec)
{
    var ctx = ctxs[cnum];
    // draw horizontal guide lines
    ctx.strokeStyle="#dddddd";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(0, by);
    ctx.lineTo(cx[cnum], by);
    ctx.moveTo(0, by + (1 - (nom - tol) / rng) * scly);
    ctx.lineTo(cx[cnum], by + (1 - (nom - tol) / rng) * scly);
    ctx.moveTo(0, by + (1 - (nom + tol) / rng) * scly);
    ctx.lineTo(cx[cnum], by + (1 - (nom + tol) / rng) * scly);
    ctx.moveTo(0, by + scly);
    ctx.lineTo(cx[cnum], by + scly);
    ctx.stroke();
    for (i=0; i<3; ++i) {
        // draw damper label ("A","B" or "C")
        ctx.font="16px verdana";
        ctx.textAlign="left";
        ctx.fillStyle="#000000";
        ctx.fillText(damperLbl[i], bx+sep*i, by*.6);
        DrawScale(cnum, bx + sep * i, min, rng, tick, lbl, dec);
        if (vals) {
            // draw color bar
            ctx.fillStyle=gradient;
            ctx.fillRect(bx+sep*i,by,10,scly);
        }
        ctx.lineWidth=.5;
        ctx.strokeStyle="#000000";
        ctx.strokeRect(bx+sep*i,by,10,scly);
        if (!vals) continue;
        // draw triangle indicator
        ctx.fillStyle=gradient;
        var val = Number(vals[i]);
        var f = val - min;
        if (f < 0) f = 0;
        else if (f > rng) f = rng;
        var y = Math.round((1 - f/rng) * scly + by);
        ctx.beginPath();
        ctx.moveTo(bx+10+sep*i,y);
        ctx.lineTo(bx+20+sep*i,y+6);
        ctx.lineTo(bx+20+sep*i,y-6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // draw indicator text
        ctx.font="16px verdana";
        ctx.textAlign="left";
        var t = val - nom - min;
        if (t > tol) {
            ctx.fillStyle="#ff0000";
        } else if (t < -tol) {
            ctx.fillStyle="#0000ff";
        } else {
            ctx.fillStyle="#008800";
        }
        ctx.fillText(val.toFixed(dec+1), bx+24+sep*i, y);
    }
}

// Draw vertical scale
// Inputs: cnum=canvas number, x=x pixel position, min=scale minimum
//         rng=scale range, tick=tick spacing, lbl=label spacing
//         dec=decimal digits
function DrawScale(cnum, x, min, rng, tick, lbl, dec)
{
    var ctx = ctxs[cnum];
    // draw scale
    ctx.strokeStyle="#000000";
    ctx.lineWidth=.5;
    ctx.fillStyle="#444444";
    ctx.font="12px verdana";
    ctx.textAlign="right";
    ctx.textBaseline="middle";
    var tol = (rng / scly) / 2.00001; // 1/2 pixel tolerance
    var y0 = Math.floor((min - tol)/tick) * tick;
    if (y0 < min - tol) y0 += tick;
    var top = min + rng + tol;
    ctx.beginPath();
    for (var y=y0; y<=top; y+=tick) {
        var pix = Math.round(by + (1 - (y - min) / rng) * scly);
        if (Math.abs(Math.round(y / lbl) * lbl - y) < tol) {
            ctx.moveTo(x-6, pix);
            ctx.fillText(y.toFixed(dec), x-8, pix);
        } else {
            ctx.moveTo(x-3, pix);
        }
        ctx.lineTo(x, pix);        
    }
    ctx.stroke();
}

// Draw position history (canvas kCanHis)
function DrawPositionHistory()
{
    var ctx = ctxs[kCanHis];
    ctx.clearRect(0, 0, cx[kCanHis], cy[kCanHis]);
    ctx.strokeStyle="#dddddd";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(bx, by + (1 - (nom - tol) / rng) * scly);
    ctx.lineTo(bx + kHistoryLen, by + (1 - (nom - tol) / rng) * scly);
    ctx.moveTo(bx, by + (1 - (nom + tol) / rng) * scly);
    ctx.lineTo(bx + kHistoryLen, by + (1 - (nom + tol) / rng) * scly);
    for (var i=0; i<=kHistoryLen; i+=60) {
        ctx.moveTo(bx + i, by);
        ctx.lineTo(bx + i, by + scly);
    }
    ctx.stroke();
    ctx.strokeStyle = '#000000';
    ctx.strokeRect(bx, by, kHistoryLen, scly);
    DrawScale(kCanHis, bx, 0, 2, .1, .5, 1);
    // draw horizontal scale
    ctx.textAlign="center";
    ctx.textBaseline="top";
    ctx.beginPath();
    for (var i=0; i<=kHistoryLen; i+=10) {
        ctx.moveTo(bx + i, by + scly);
        var len;
        if (!(i % 60)) {
            ctx.fillText(i/60, bx + i, by + scly + 6);
            len = 6;
        } else if (!(i % 30)) {
            len = 5;
        } else {
            len = 3;
        }
        ctx.lineTo(bx + i, by + scly + len);
    }
    ctx.stroke();
    // draw title/legend
    ctx.lineWidth=1;
    ctx.font="16px verdana";
    ctx.textAlign="right";
    ctx.textBaseline="alphabetic";
    ctx.fillStyle="#444444";
    ctx.fillText("Damper position history:", bx + kHistoryLen/2, 23);
    for (var i=0; i<3; ++i) {
        ctx.beginPath();
        var x = bx + kHistoryLen/2 + (i + 1) * 60;
        ctx.moveTo(x, 18);
        ctx.lineTo(x + 20, 18);
        ctx.strokeStyle = damperCol[i];
        ctx.stroke();
        ctx.fillText(damperLbl[i], x - 5, 23);
    }
    ctx.textAlign="center";
    ctx.fillText("Past time (min)", bx + kHistoryLen/2, by + scly + 35);
    if (!his.length) return;
    for (var i=0; i<3; ++i) {
        var lasty = null;
        ctx.beginPath();
        // (start drawing at history element 1 because 0 may not be final)
        for (var j=1; j<his.length; ++j) {
            if (lasty != null) {
                ctx.lineTo(bx+j, lasty);
            }
            if (typeof his[j][i] == 'undefined') {
                lasty = null;
                continue;
            }
            var y = Math.round((1 - (his[j][i]-min)/rng) * scly + by);
            if (lasty == null) {
                ctx.moveTo(bx+j, y);
            } else {
                ctx.lineTo(bx+j, y);
            }
            lasty = y;
        }
        ctx.strokeStyle = damperCol[i];
        ctx.stroke();
    }
    needDrawHis = 0;
}

// Clear all canvases
function ClearAll()
{
    DrawDamperPositions();
    DrawPositionHistory();
    DrawDamperLoads();
    DrawSpeeds();
}

// Forget about server after disconnect, then try to reconnect again
function ForgetServer(ws)
{
    if (ws == cuteServer) {
        ClearAll();     // clear all indicators
        cuteServer = null;
        setTimeout(ConnectToServer, 1000);  // try to reconnect again later
    }
}

// Add measurements to history
function AddToHistory(time, vals)
{
    if (hisTime == time) {
        his[0] = vals;          // replace in history
    } else {
        for (;;) {
            if (++hisTime == time) break;
            if (hisTime == 0) { // (was -1)
                hisTime = time;
                break;
            }
            if ((hisTime %= kHistoryLen) == time) break;
            his.unshift([]);    // pad with nulls
        }
        his.unshift(vals);      // add to history
        // trim history length
        if (his.length > kHistoryLen) {
            his.splice(kHistoryLen, his.length - kHistoryLen);
        }
        needDrawHis = 1;        // redraw history plot
    }
}

// Connect to and communicate with CUTE cryostat server
function ConnectToServer()
{
    if (cuteServer) return; // allow only one server object

    try {
        var host = window.location.hostname;
        var port = 8080;
        if (host == "") host = "localhost";
        console.log(host+":"+port);
        var ws = new WebSocket("ws://"+host+":"+port, ["cute", "test"]);
        cuteServer = ws;
        ws.onopen = function() {
            if (ws != cuteServer) {
                ws.close();
                return;
            }

            // handle messages from server
            ws.onmessage = function(message) {
                if (ws != cuteServer) {
                    ws.close();
                    return;
                }
                var c = message.data.substr(0,1);
                var msg = message.data.substr(2);
                switch (c) {
                    case 'A': { // damper positions
                        var v = msg.split(' ');
                        var t = Number(v.shift());
                        DrawDamperPositions(v);
                        AddToHistory(t, v);
                        // draw history plot if necessary
                        if (needDrawHis) DrawPositionHistory();
                        airPressure = 1003 + 10 * v[3];
                        air.innerHTML = airPressure.toFixed(1);
                        DrawDamperLoads([25, 25, 25]);
                    } break;
    
                    case 'B': { // history
                        var v = msg.split(' ');
                        var t = Number(v.shift());
                        AddToHistory(t, v);
                    } break;
                    
                    case 'C':   // console log
                        var log = document.getElementById('log');
                        var lines = log.innerHTML.split('\n');
                        if (lines.length > 200) lines.shift();
                        lines.push(msg);
                        log.innerHTML = lines.join('\n');
                        log.scrollTop = log.scrollHeight;
                        break;
    
                    case 'D': { // system active/inactive
                        active = msg;
                        title.style.backgroundColor = (msg == 1 ? '#ccffcc' : '#ffcccc');
                        Activate(active);   // update radio buttons
                        DrawSpeeds(active==1 ? [100,0,-40] : [0,0,0]); //TEST
                            
                    } break;
                }
            };
        };
        ws.onclose = function(event) {
            ForgetServer(ws);
        };
        ws.onerror = function() {
            ws.close();
            ForgetServer(ws);
        };
    }
    catch (err) {
        if (err) ForgetServer(ws);
    }
}

//-----------------------------------------------------------------------------
// main script

ClearAll();
ConnectToServer();

</script>

</body>
</html>

